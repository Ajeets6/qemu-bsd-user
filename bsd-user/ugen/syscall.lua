--
-- SPDX-License-Identifier: BSD-2-Clause
--
-- Copyright (c) 2023 Warner Losh <imp@bsdimp.com>
--

args = require("args")

local syscall = {}

syscall.__index = syscall

syscall.known_flags = {
	STD,
	OBSOL,
	RESERVED,
	UNIMPL,
	NODEF,
	NOARGS,
	NOPROTO,
	NOSTD,
	NOTSTATIC,
	CAPENABLED,
	SYSMUX,
}

-- All compat option entries should have five entries:
--	definition: The preprocessor macro that will be set for this
--	compatlevel: The level this compatibility should be included at.  This
--	    generally represents the version of FreeBSD that it is compatible
--	    with, but ultimately it's just the level of mincompat in which it's
--	    included.
--	flag: The name of the flag in syscalls.master.
--	prefix: The prefix to use for _args and syscall prototype.  This will be
--	    used as-is, without "_" or any other character appended.
--	descr: The description of this compat option in init_sysent.c comments.
-- The special "stdcompat" entry will cause the other five to be autogenerated.
local compat_option_sets = {
	native = {
		{
			definition = "COMPAT_43",
			compatlevel = 3,
			flag = "COMPAT",
			prefix = "o",
			descr = "old",
		},
		{ stdcompat = "FREEBSD4" },
		{ stdcompat = "FREEBSD6" },
		{ stdcompat = "FREEBSD7" },
		{ stdcompat = "FREEBSD10" },
		{ stdcompat = "FREEBSD11" },
		{ stdcompat = "FREEBSD12" },
		{ stdcompat = "FREEBSD13" },
	},
}

-- XXX need to sort out how to do compat stuff...
-- native is the only compat thing
-- Also need to figure out the different other things that 'filter' system calls
-- since the abi32 stuff does that.

--
-- We build up the system call one line at a time, as we pass through 4 states
-- We don't have an explicit state name here, but maybe we should
--
function syscall:add(line)
	local words = {}

	for w in line:gmatch("%S+") do
		table.insert(words, w)
	end

	-- starting
	if self.num == nil then
		-- sort out range somehow XXX
		-- Also, where to put validation of no skipped syscall #? XXX
		self.num = words[1]
		self.audit = words[2]
		self.type = words[3]
		self.name = words[4]
		return self.name ~= "{"
	end

	-- parse function name
	if self.name == "{" then
		-- Expect line is "type syscall(" or "type syscall(void);"
		if #words ~= 2 then
			abort(1, "Malformed line " .. line)
		end
		self.rettype = words[1]
		self.name = words[2]:gsub("%(.*$", "")
		if words[2]:match("%);$") then
			self.expect_rbrace = true
		end
		return false
	end

	-- eating args
	if not self.expect_rbrace then
		-- We're looking for (another) argument
		-- xxx copout for the moment and just snarf the argument
		-- some have trailing , on last arg
		if line:match("%);$") then
			self.expect_rbrace = true
			return false
		end

		local arg = args:new({ }, line)
		table.insert(self.args, arg)
		return false
	end

	-- state wrapping up, can only get } here
	if not line:match("}$") then
		abort(1, "Expected '}' found '" .. line .. "' instead.")
	end
	return true
end

function syscall:new(obj)
	obj = obj or { }
	setmetatable(obj, self)
	self.__index = self

	self.expect_rbrace = false
	self.args = { }

	return obj
end

return syscall

